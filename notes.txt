Vulkan sdk
location
/etc/vulkan/icd.d/ or /usr/share/vulkan/icd.d 	Vulkan driver JSON manifest file, which is not modified by the SDK installer.

GLSLC
Location: /usr/local/bin/glslc
Does not recognise .vs and .fs. But recognized .vs .fs

Vulkan usa muito typedef para facilitar o gerenciamento dos dados pois os typedef ja definem como os objects serao formatados.

In game engines/development, its a good option to go for ECS over Object Oriented (inheritance). ECS stands for Entity component system.
Its focused on association over inheritance. Like, entities having behavior being applied to an entity (a game object) by a component.
https://www.kodeco.com/2806-introduction-to-component-based-architecture-in-games



In tutorial, device, pipeline, window and maybe other artifacts are called lve_filename.ext. Ex: lve_window.cpp.
I'm removing its prefix to be generic, but applied them to classes. But instead of lve, i'm using uffdejavu for namespace and UD for 
classes prefix.

In vulkan, it happens many times that instead of calling many parameters, we create a struct and refer to its pointer.

Required extensions are defined by glfw to display content

Swap chain: Is a series of framebuffers used to dfiplay images to the window. Modern OSs usually have at least 2 buffers
at once (double buffering). The frontbuffer and backbuffer. Pipeline renders data to the backbuffer, and when ready, 
the swap chain handles coordinating with the display prior to vertical sync. When swapped, while backbuffer is being displayed,
the gpu pipeline will output the data into tha frontbuffer. 
They are basically equal and swapped to display the data.

Tearing: Seeing data from multiple frames at once.

We will work with multiple framebuffers (2 or 3)
We can use swapChain.acquireNextImage() to get the next index of our framebuffers


Sure, in the context of Vulkan, passes and subpasses are related to the concept of Render Passes.

**Render Passes** in Vulkan represent a collection of graphics rendering operations that are related to each other. 
The operations are grouped together because they are expected to be executed sequentially. 
A render pass in Vulkan describes the format of the framebuffers, the number of color and depth buffers, 
the samples used for each buffer, and what to do with the data in the buffers throughout rendering operations.
**Subpasses** are a part of a render pass. They represent a single rendering operation within the larger render pass. Subpasses can depend on each other, meaning the output of one subpass can be used as input to another subpass. This allows for efficient hardware utilization as the output of one subpass can be directly used by another subpass without having to write it to memory and then read it back.

For example, in a deferred shading pipeline, you might have one subpass that writes to a G-buffer, and a second subpass that reads from the G-buffer to perform lighting calculations. By using subpasses, Vulkan can optimize this so that the G-buffer data doesn't need to be written out to memory and then read back in between the two subpasses.

**Passes** in this context usually refer to the entire render pass, which includes all of its subpasses.

In summary, render passes and subpasses are a way for you to tell Vulkan about the dependencies between different rendering operations, which allows Vulkan to optimize the execution of these operations for better performance.

Ao trocar dados entre shaders, o layout tem que ser o mesmo entre quem envia e quem recebe. O nome das variaveis nao precisa ser igual3

--
Linear Interpolation (L. I.)
P = a(1-t) + bt  --// If multi dimensional, Px = ax(1-t) + bt and so on.
Where a is a and b are points with absolute known values. 
t is the interpolation point proximity that lies between a and b. Where t = [0,1]

L. I. between many points: Barycentric coordinates.

3 points a, b and c
What is the interpolated value of a point P inside this triangle?
P = b*Beta + c*Gamma + a(1-Beta-Gama) (weights of b and c); Alpha = 1 - Beta - Gamma
then P = a*Alpha + b*Beta = c*Gamma ; Alpha + Beta + Gamma = 1 (constraint). Alpha, Beta and Gamma MUST be (0, 1)

assert vs if
If deals with pathes in the code, the decision conditions.
Assert is used when you expect only 1 behavior and the assertion should be a big exception (therefore, possibly error handling to some point)

** Estudar depois com mais calma: Coordandas homogeneas. Para melhor desenvolver questoes de translacao e transformacoes



--Codigo do siepisnki triangle

void FirstApp::sierpinski(
    std::vector<LveModel::Vertex> &vertices,
    int depth,
    glm::vec2 left,
    glm::vec2 right,
    glm::vec2 top) {
  if (depth <= 0) {
    vertices.push_back({top});
    vertices.push_back({right});
    vertices.push_back({left});
  } else {
    auto leftTop = 0.5f * (left + top);
    auto rightTop = 0.5f * (right + top);
    auto leftRight = 0.5f * (left + right);
    sierpinski(vertices, depth - 1, left, leftRight, leftTop);
    sierpinski(vertices, depth - 1, leftRight, right, rightTop);
    sierpinski(vertices, depth - 1, leftTop, rightTop, top);
  }
}
void FirstApp::loadModels() {
  std::vector<LveModel::Vertex> vertices{};
  sierpinski(vertices, 5, {-0.5f, 0.5f}, {0.5f, 0.5f}, {0.0f, -0.5f});
  lveModel = std::make_unique<LveModel>(lveDevice, vertices);
}